\chapter{Implementation}
The implemention of the application can roughly be divided into two parts: A server, being the layer between the user and the database, and a client presenting the data to the user. This chapter will describe the requirements for each part, the technical challenges of the project and how they were met. 


\section{Choice of platform}
We decided to create a web based solution instead of a desktop application, mostly based on the nature of the project but also on our own interests. The web based solution does not require a client to be installed on the users system, which makes it instantly accessible. The webbased solution also makes the program available on any device with an internet connection; from a laptop, a smartphone or a dedicated monitor at ITU.\\

This is of course a tradeoff, as we have much more experience with developing desktop applications, which would probably be much faster and cause fewer errors to debug. However, we do think it was a natural choice to put the application on the internet, because of the large number of people who will use it everyday.

\section{Language}
Since we mainly focus on the UI, we wanted to use a framework for the development process, giving us some functionality "out of the box". This would reduce the time spent on the technial implementation, and give us more time to focus on the UI.\\
We have chosen to use \emph{Scala}\cite{scala} as the implementation language; a multi-paradigm language running on the JVM. Scala is a superset of java, featuring some functional programming constructs, like pattern matching and immutable types. While it is possible to use the java libraries, Scala provides many immutable alternatives to make concurrent programming easier. \\

A large motivation for choosing Scala, was the rich functionality provided by the Scala based web framework \emph{Lift} \cite{lift}. Lift is designed as a framework for developing web applications, with a high focus on security and performance. Lift provides us with the following functionality relevant to our project:

\begin{itemize}
	\item \textbf{Sitemap}\\
	A sitemap is used to represent the structure of a website. Each page in the structure can be specified to require a certain level of authorization to be accessible. \\
	\item \textbf{Sessions}\\
	Lift support handling of multiple users with sessions. A session is a cookie, with some information about the user associated with it.\\
	\item \textbf{Xml bindings}\\
	Lift uses xml as reference points for dynamic code injection. The static parts of the application are built using normal HTML. XML are used as placeholders, or bindings, for the data that are supposed to change during a session. This makes it possible to completely seperate the development of the presentation layer (the client), and the data layer (the server).
\end{itemize}

Lift is thus giving us a lot of the functionality we need to make our application work, but it also poses a large challenge, as Lift requires decent experience with Scala, which we do not yet have.

\section{Development environment}
\label{sec:development_environment}
During development, we have used a tool called Simple Build Tool(SBT)\cite{sbt} to compile and test our application. SBT comes with a local web server (called Jetty), and a Lift project template, seperating the client and server. Appendix \ref{app:lift_structure} describes the basic structure of such a project.\\
SBT support automatic compiling, so when a file included in the project is changed, Jetty will automatically compile the changed file(s) and restart the webserver.

\section{Technical requirements}
\label{sec:tech_req}
This section describes the technical requirements for the server and the client. General requirements have been described in section \ref{subsec:functional_requirements}, and the actual implementation will be discussed in section \ref{xxxx}.

\subsection{Server}
\label{sub:req_server}
\begin{itemize}
	\item \textbf{General authorization}\\
	The server should not allow access to the system unless the user is logged in. The sitemap functionality in Lift should be used to request authorization and present the appropriate pages.
	\item \textbf{User levels}\\
	In our system, we need two different user roles; one for staff members which should have access to the semester planning application(\emph{super users}), and one for all other users (\emph{basic users}). Specific user roles are assigned an integer indicating the users \emph{level}. Super users are level 2, while basic users are level 1. The server should use the sitemap to only present the semester planning to super users, thus users with a level of 2. 
	\item \textbf{Support of multiple users}\\
	Lift Sessions should be used to distinguish users from each other. The Session associated with a user is not a placeholder for the actual user \emph{object}, but merely a unique identifier. The Session cookie should only contain the unique ID of the user, fetched from the database.
\end{itemize}

\subsection{Client}
\label{sub:req_client}
\begin{itemize}
	\item \textbf{Clickable map with server callback}\\
	The client should present a clickable map of the rooms at ITU. When the user selects a room, the view should change and let the user book the selected room for the current day. This requires that the client sends data to the server, which is usually done within a <form> element using a submit button. However, as we are dealing with a clickable image, this is not an option. Lift does not support interactions with images, but does support callbacks from javascript functions. We can thus use a html clickable map\cite{html_map}, and attach a javascript callback through Lift, enabling us to call a function when the user selects a room.
	\item \textbf{Interactive Calendar}\\
	The users should be able to select a different day than the current, giving them the option to book a room in advance. JQueryui\cite{jqueryui} offers a datepicker widget\cite{jqueryui_date}, which supports this functionality.
	\item \textbf{Custom time and day picker}\\
	Because our day and time picker \ref{chap2_req:xx} is a custom made widget and very application specific, it has to be made from scratch. Since Lift support callbacks through javascript, it's possible to create such a widget by using this functionality together with simple html attributes as date and time identifiers.
\end{itemize}

\section{Database design}
\label{sec:database_design}
From the requirements in section \ref{sec:requirements} and the technical requirements above, we derived the database design seen in figure \ref{fig:db_design}. While parts of the design are trivial, here follows the ideas behind some of the more non trivial elements.

\begin{figure}[htb]
\begin{center}
\leavevmode
\includegraphics[width=0.6\textwidth]{images/db-design.png}
\end{center}
\caption{Database design}
\label{fig:db_design}
\end{figure}

\subsection{Course and planning table}
\label{sub:course_planning_table}
The course tabel contains information about a specific course. It should be possible to create a course without immediately adding it to the semester planning, which is why the two tables seem to contain some of the same data. The \emph{room\_req} field is a \emph{room request} field. We learned from section \ref{xx} that teachers often have specific room requests, which this field reflects. This might be a wish, or an actual request which should be respected by the application, if e.g. a course requires equipment only available in one room. In that case, the \emph{req\_req} field is set to 1, indicating that this is a constraint and not a wish. 

\subsection{Day and time modelling}
\label{sub:day_and_time_modelling}
We have chosen not to use the built in date field type in MySQL, because we use javascript to exchange data between the client and the server. Javascript does not understand this data type by default, and while it might be possible to write a function that creates an object representing the same type, we will still have to deal with string splitting and concatination. This is very inefficient and takes up more space compared to using simple integers.\\
We have thus used integers to represent all kinds of date and time data. An example is the \emph{booking} table, which contains information about a specific booking. \emph{time} and \emph{endtime} represents the start time and end time of the booking respectively, by the number of minutes after midnight. If a booking starts 10.30 in the morning, the start time field will thus be 630. This way of representing the time has a couple of advantages:

\begin{itemize}
	\item Simple calculations can be used to find the duration of a booking, and the actual time the fields represent. We do not need to work with strings, which makes the code clearner and more efficient.
	\item For the same reason, user validation is quick and easy to perform.
	\item We can still execute specific date and time sql queries by using basic relationel operators, which makes it more efficient to e.g. lookup bookings after a specific time.
\end{itemize}



\todo{How to implement, discussion of for and against our choices of platform, language, etc etc. Possibly split this in to several sections}

\section{Challenges}
\label{sec:challenges}
% info found in: 'concurrent_room_selection-11-02-03', 'meeting_study-administration_11-03-16' and 'courses_spanning_multiple_days'
\subsection{Concurrent room selection}
\label{sub:challenges_concurrent_rooms}
The handling of concurrent users is always an issue in webbased services, and more specifically in our case it presents itself when multiple users wants to book a room at the same time. No solutions are perfect, and we've tried discovering the pros and cons of the solutions we considered.

\subsubsection*{Possible solutions}
These solutions are based on the the case where users \textbf{X} and \textbf{Y} are searching for rooms at the same time. They could obviously be extrapolated to cases where even more users are interacting. 
\subsubsection*{Solution 1}
\begin{tabular}{|p{6cm}|p{6cm}|}
\hline 
	\multicolumn{2}{|p{12cm}|}{Make all rooms that fits \textbf{X}, unavailable for \textbf{Y} while \textbf{X} is deciding on which room to use.} \\ \hline \hline
	\multicolumn{1}{|c|}{\textbf{Pros}} & \multicolumn{1}{c|}{\textbf{Cons}} \\ \hline
	Easy to implement & If all rooms fit the search of \textbf{X}, no rooms will be available for \textbf{Y} \\ \hline
	Extremely unlikely to encounter dead ends. & \\
	\hline
\end{tabular}
\\
\subsubsection*{Solution 2}
\begin{tabular}{|p{6cm}|p{6cm}|}
\hline
	\multicolumn{2}{|p{12cm}|}{The screen which shows available rooms for user \textbf{Y} should update when user \textbf{X} makes a booking.} \\ \hline \hline
	\multicolumn{1}{|c|}{\textbf{Pros}} & \multicolumn{1}{c|}{\textbf{Cons}} \\ \hline
	High usability and responsiveness, resulting in a pleasant experience for the user if no dead ends are hit. & Increased number of requests to the server. \\ \hline
	More flexible; allows several users to have many choices at once. & Dead ends are a possibility. \\
	\hline
	\multicolumn{2}{|p{12cm}|}{Ultimately, it is a tradeoff between probability of dead ends vs. server request-rate.} \\
	\hline
\end{tabular}

\todo{Write an implementation section for both the client and server. Mention the use of photoshop!}