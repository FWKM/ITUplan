\chapter{Implementation}
The implemention of the application can roughly be divided into two parts: A server, being the layer between the user and the database, and a client presenting the data to the user. This chapter will describe the requirements for each part, the technical challenges of the project and how they were met. 


\section{Choice of platform}
We decided to create a web based solution instead of a desktop application, mostly based on the nature of the project but also on our own interests. The web based solution does not require a client to be installed on the users system, which makes it instantly accessible. The webbased solution also makes the program available on any device with an internet connection; from a laptop, a smartphone or a dedicated monitor at ITU.\\

This is of course a tradeoff, as we have much more experience with developing desktop applications, which would probably be much faster and cause fewer errors to debug. However, we do think it was a natural choice to put the application on the internet, because of the large number of people who will use it everyday.

\section{Language}
Since we mainly focus on the UI, we wanted to use a framework for the development process, giving us some functionality "out of the box". This would reduce the time spent on the technial implementation, and give us more time to focus on the UI.\\
We have chosen to use \emph{Scala}\cite{scala} as the implementation language; a multi-paradigm language running on the JVM. Scala is a superset of java, featuring some functional programming constructs, like pattern matching and immutable types. While it is possible to use the java libraries, Scala provides many immutable alternatives to make concurrent programming easier. \\

A large motivation for choosing Scala, was the rich functionality provided by the Scala based web framework \emph{Lift} \cite{lift}. Lift is designed as a framework for developing web applications, with a high focus on security and performance. Lift provides us with the following functionality relevant to our project:

\begin{itemize}
	\item \textbf{Sitemap}\\
	A sitemap is used to represent the structure of a website. Each page in the structure can be specified to require a certain level of authorization to be accessible. \\
	\item \textbf{Sessions}\\
	Lift support handling of multiple users with sessions. A session is a cookie, with some information about the user associated with it.\\
	\item \textbf{Xml bindings}\\
	Lift uses xml as reference points for dynamic code injection. The static parts of the application are built using normal HTML. XML are used as placeholders, or bindings, for the data that are supposed to change during a session. This makes it possible to completely seperate the development of the presentation layer (the client), and the data layer (the server).
\end{itemize}

Lift is thus giving us a lot of the functionality we need to make our application work, but it also poses a large challenge, as Lift requires decent experience with Scala, which we do not yet have.

\section{Development environment}
\label{sec:development_environment}
During development, we have used a tool called Simple Build Tool(SBT)\cite{sbt} to compile and test our application. SBT comes with a local web server (called Jetty), and a Lift project template, seperating the client and server. Appendix \ref{app:lift_structure} describes the basic structure of such a project.\\
SBT support automatic compiling, so when a file included in the project is changed, Jetty will automatically compile the changed file(s) and restart the webserver.

\section{Technical requirements}
\label{sec:tech_req}
This section describes the technical requirements for the server and the client. General requirements have been described in section \ref{subsec:functional_requirements}, and the actual implementation will be discussed in section \ref{xxxx}.

\subsection{Server}
\label{sub:req_server}
\begin{itemize}
	\item \textbf{General authorization}\\
	The server should not allow access to the system unless the user is logged in. The sitemap functionality in Lift should be used to request authorization and present the appropriate pages.
	\item \textbf{User levels}\\
	In our system, we need two different user roles; one for staff members which should have access to the semester planning application(\emph{super users}), and one for all other users (\emph{basic users}). Specific user roles are assigned an integer indicating the users \emph{level}. Super users are level 2, while basic users are level 1. The server should use the sitemap to only present the semester planning to super users, thus users with a level of 2. 
	\item \textbf{Support of multiple users}\\
	Lift Sessions should be used to distinguish users from each other. The Session associated with a user is not a placeholder for the actual user \emph{object}, but merely a unique identifier. The Session cookie should only contain the unique ID of the user, fetched from the database.
\end{itemize}

\subsection{Client}
\label{sub:req_client}
\begin{itemize}
	\item \textbf{Clickable map with server callback}\\
	The client should present a clickable map of the rooms at ITU. When the user selects a room, the view should change and let the user book the selected room for the current day. This requires that the client sends data to the server, which is usually done within a <form> element using a submit button. However, as we are dealing with a clickable image, this is not an option. Lift does not support interactions with images, but does support callbacks from javascript functions. We can thus use a html clickable map\cite{html_map}, and attach a javascript callback through Lift, enabling us to call a function when the user selects a room.
	\item \textbf{Interactive Calendar}\\
	The users should be able to select a different day than the current, giving them the option to book a room in advance. JQueryui\cite{jqueryui} offers a datepicker widget\cite{jqueryui_date}, which supports this functionality.
	\item \textbf{Custom time and day picker}\\
	Because our day and time picker \ref{chap2_req:xx} is a custom made widget and very application specific, it has to be made from scratch. Since Lift support callbacks through javascript, it's possible to create such a widget by using this functionality together with simple html attributes as date and time identifiers.
\end{itemize}

\section{Database design}
\label{sec:database_design}


\todo{How to implement, discussion of for and against our choices of platform, language, etc etc. Possibly split this in to several sections}

\section{Challenges}
\label{sec:challenges}
% info found in: 'concurrent_room_selection-11-02-03', 'meeting_study-administration_11-03-16' and 'courses_spanning_multiple_days'
\subsection{Concurrent room selection}
\label{sub:challenges_concurrent_rooms}
The handling of concurrent users is always an issue in webbased services, and more specifically in our case it presents itself when multiple users wants to book a room at the same time. No solutions are perfect, and we've tried discovering the pros and cons of the solutions we considered.

\subsubsection*{Possible solutions}
These solutions are based on the the case where users \textbf{X} and \textbf{Y} are searching for rooms at the same time. They could obviously be extrapolated to cases where even more users are interacting. 
\subsubsection*{Solution 1}
\begin{tabular}{|p{6cm}|p{6cm}|}
\hline 
	\multicolumn{2}{|p{12cm}|}{Make all rooms that fits \textbf{X}, unavailable for \textbf{Y} while \textbf{X} is deciding on which room to use.} \\ \hline \hline
	\multicolumn{1}{|c|}{\textbf{Pros}} & \multicolumn{1}{c|}{\textbf{Cons}} \\ \hline
	Easy to implement & If all rooms fit the search of \textbf{X}, no rooms will be available for \textbf{Y} \\ \hline
	Extremely unlikely to encounter dead ends. & \\
	\hline
\end{tabular}
\\
\subsubsection*{Solution 2}
\begin{tabular}{|p{6cm}|p{6cm}|}
\hline
	\multicolumn{2}{|p{12cm}|}{The screen which shows available rooms for user \textbf{Y} should update when user \textbf{X} makes a booking.} \\ \hline \hline
	\multicolumn{1}{|c|}{\textbf{Pros}} & \multicolumn{1}{c|}{\textbf{Cons}} \\ \hline
	High usability and responsiveness, resulting in a pleasant experience for the user if no dead ends are hit. & Increased number of requests to the server. \\ \hline
	More flexible; allows several users to have many choices at once. & Dead ends are a possibility. \\
	\hline
	\multicolumn{2}{|p{12cm}|}{Ultimately, it is a tradeoff between probability of dead ends vs. server request-rate.} \\
	\hline
\end{tabular}

\todo{Write an implementation section for both the client and server. Mention the use of photoshop!}
\section{Datastructures}
\todo{Introduction to this section}

\subsection{Datamodel}
\todo{Explain our database design and datamodel}

\subsection{Algorithms}
\todo{Outline the important algorithms in our program, and why they are awesome}

\section{Server-Client relationship}
\todo{Explain the design; what we do, and what lift handles for us.}

\section{Lift}
\todo{This section probably doesn't belong here, but it needs to be somewhere.}