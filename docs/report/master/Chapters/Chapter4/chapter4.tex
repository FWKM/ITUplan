\chapter{Implementation}
The implemention of the application can roughly be divided into two parts: A server, being the layer between the user and the database, and a client presenting the data to the user. This chapter will describe the requirements for each part, the technical challenges of the project and how they were met. 


\section{Choice of platform}
We decided to create a web based solution instead of a desktop application, mostly based on the nature of the project but also on our own interests. The web based solution does not require a client to be installed on the users system, which makes it instantly accessible. The webbased solution also makes the program available on any device with an internet connection; from a laptop, a smartphone or a dedicated monitor at ITU.\\

This is of course a tradeoff, as we have much more experience with developing desktop applications, which would probably be much faster and cause fewer errors to debug. However, we do think it was a natural choice to put the application on the internet, because of the large number of people who will use it everyday.

\section{Language}
Since we mainly focus on the UI, we wanted to use a framework for the development process, giving us some functionality "out of the box". This would reduce the time spent on the technial implementation, and give us more time to focus on the UI.\\
We have chosen to use \emph{Scala}\cite{scala} as the implementation language; a multi-paradigm language running on the JVM. Scala is a superset of java, featuring some functional programming constructs, like pattern matching and immutable types. While it is possible to use the java libraries, Scala provides many immutable alternatives to make concurrent programming easier. \\

A large motivation for choosing Scala, was the rich functionality provided by the Scala based web framework \emph{Lift} \cite{lift}. Lift is designed as a framework for developing web applications, with a high focus on security and performance. Lift provides us with the following functionality relevant to our project:

\begin{itemize}
	\item \textbf{Sitemap}\\
	A sitemap is used to represent the structure of a website. Each page in the structure can be specified to require a certain level of authorization to be accessible. \\
	\item \textbf{Sessions}\\
	Lift support handling of multiple users with sessions. A session is a cookie, with some information about the user associated with it.\\
	\item \textbf{Xml bindings}\\
	Lift uses xml as reference points for dynamic code injection. The static parts of the application are built using normal HTML. XML are used as placeholders, or bindings, for the data that are supposed to change during a session. This makes it possible to completely seperate the development of the presentation layer (the client), and the data layer (the server).
\end{itemize}

Lift is thus giving us a lot of the functionality we need to make our application work, but it also poses a large challenge, as Lift requires decent experience with Scala, which we do not yet have.

\section{Development environment}
\label{sec:development_environment}
During development, we have used a tool called Simple Build Tool(SBT)\cite{sbt} to compile and test our application. SBT comes with a local web server, and a Lift project template, seperating the client and server. Appendix \ref{app:lift_structure} describes the basic structure of such a project.

\section{Technical requirements}
\label{sec:tech_req}

\subsection{Server}
\label{sub:server}
The server is the layer between the user and the database, taking care of all transactions. It should be able to handle multiple users at once, and handle different user roles.


\todo{How to implement, discussion of for and against our choices of platform, language, etc etc. Possibly split this in to several sections}

\section{Challenges}
\label{sec:challenges}
\todo{What challenges must our user interface overcome?}
\\
% info found in: 'concurrent_room_selection-11-02-03', 'meeting_study-administration_11-03-16' and 'courses_spanning_multiple_days'
\subsection{Concurrent room selection}
The handling of concurrent users is always an issue in webbased services, and more specifically in our case it presents itself when multiple users wants to book a room at the same time. No solutions are perfect, and we've tried discovering the pros and cons of the solutions we considered.

\subsubsection*{Possible solutions}
These solutions are based on the the case where users \textbf{X} and \textbf{Y} are searching for rooms at the same time. They could obviously be extrapolated to cases where even more users are interacting. 
\subsubsection*{Solution 1}
\begin{tabular}{|p{6cm}|p{6cm}|}
\hline 
	\multicolumn{2}{|p{12cm}|}{Make all rooms that fits \textbf{X}, unavailable for \textbf{Y} while \textbf{X} is deciding on which room to use.} \\ \hline \hline
	\multicolumn{1}{|c|}{\textbf{Pros}} & \multicolumn{1}{c|}{\textbf{Cons}} \\ \hline
	Easy to implement & If all rooms fit the search of \textbf{X}, no rooms will be available for \textbf{Y} \\ \hline
	Extremely unlikely to encounter dead ends. & \\
	\hline
\end{tabular}
\\
\subsubsection*{Solution 2}
\begin{tabular}{|p{6cm}|p{6cm}|}
\hline
	\multicolumn{2}{|p{12cm}|}{The screen which shows available rooms for user \textbf{Y} should update when user \textbf{X} makes a booking.} \\ \hline \hline
	\multicolumn{1}{|c|}{\textbf{Pros}} & \multicolumn{1}{c|}{\textbf{Cons}} \\ \hline
	High usability and responsiveness, resulting in a pleasant experience for the user if no dead ends are hit. & Increased number of requests to the server. \\ \hline
	More flexible; allows several users to have many choices at once. & Dead ends are a possibility. \\
	\hline
	\multicolumn{2}{|p{12cm}|}{Ultimately, it is a tradeoff between probability of dead ends vs. server request-rate.} \\
	\hline
\end{tabular}

\section{Datastructures}
\todo{Introduction to this section}

\subsection{Datamodel}
\todo{Explain our database design and datamodel}

\subsection{Algorithms}
\todo{Outline the important algorithms in our program, and why they are awesome}

\section{Server-Client relationship}
\todo{Explain the design; what we do, and what lift handles for us.}

\section{Lift}
\todo{This section probably doesn't belong here, but it needs to be somewhere.}